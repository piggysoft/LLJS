extern undefined;
extern print;
extern console;
extern snarf;
extern process;
extern newGlobal;
extern setDebug;
extern ArrayBuffer;
extern Uint8Array;
extern Uint32Array;


let NODE_JS = 1;
let JS_SHELL = 2;
let BROWSER = 3;


let mode;
if (typeof process !== "undefined") {
  mode = NODE_JS;
} else if (typeof snarf !== "undefined") {
  mode = JS_SHELL;
} else {
  mode = BROWSER;
}

let ck, root, dbg;
if (mode === NODE_JS) {
  print = console.log;
} 

let memcheck = {}; 

// The shadow memory (SM) is a typed array with a corresponding U1
// view that holds a addresssable/defined flag (FLAG_ACC and FLAG_DEF)
// for each byte of main memory.
let u8 FLAG_ACC = 0x1;
let u8 FLAG_DEF = 0x2;

let SM;
let viewSM;

function reset(memSize) {
  SM = new ArrayBuffer(memSize);
  viewSM = new Uint8Array(SM);
  
  memcheck = {
    // {byte* => [bool, str]}
    used: [],
    errors: {
      // [byte*]
      double_free: [],
      // [{membyte: byte*, trace: [str]]
      bad_access: [],
      // [{membyte: byte*, trace: [str]]
      undef_access: []
    }
  };
}

function setFlag(byte *idx, uint size, uint mask) {
  for (let uint i = 0; i < size; i++) {
    viewSM[idx + i] |= mask;
  }
}

function clearFlag(byte *idx, uint size, uint mask) {
  for (let uint i = 0; i < size; i++) {
    viewSM[idx + i] &= ~mask;
  }
}


// (byte, uint, bool) -> unit
function setAddressable(byte *bt, uint size, on) {
  if(on) {
    setFlag(bt, size, FLAG_ACC);
  } else {
    clearFlag(bt, size, FLAG_ACC);
  }
}

// (byte) -> bool
function isAddressable(byte *bt) {
  if(viewSM[bt] & FLAG_ACC) {
    return true;
  } else {
    return false;
  }
}

// (byte, uint, bool) -> unit
function setDefined(byte *bt, uint size, on) {
  if(on) {
    setFlag(bt, size, FLAG_DEF);
  } else {
    clearFlag(bt, size, FLAG_DEF);
  }
}

// (byte) -> bool
function isDefined(byte *bt) {
  if(viewSM[bt] & FLAG_DEF) {
    return true;
  } else {
    return false;
  }
}

// (byte, bool) -> unit
function setAlloc(byte *bt, value) {
  memcheck.used[bt] = {isalloc:value, trace: callstack.slice(0)};
}

           

// (byte) -> bool
function isAlloc(byte *bt) {
  if(typeof memcheck.used[bt] !== 'undefined') {
    return memcheck.used[bt].isalloc;
  }
  return false;
}


// (str, str) -> unit
function addError(kind, msg) {
  if(memcheck.errors[kind] === undefined) {
    memcheck.errors[kind] = [];
  }
  memcheck.errors[kind].push(msg);
}

function addDoubleFreeError(byte *bt) {
  memcheck.errors.double_free.push({membyte: bt, trace: callstack.slice(0)});
} 

function addBadAccessError(byte *bt) {
  memcheck.errors.bad_access.push({membyte: bt, trace: callstack.slice(0) });
}

function addUndefinedError(byte *bt) {
  memcheck.errors.undef_access.push({membyte: bt, trace: callstack.slice(0)});
}

// unit -> [byte*]
function getBadAccesses() {
  return memcheck.errors.bad_access;
}

// unit -> [byte*]
function getBadUndefined() {
  return memcheck.errors.undef_access;
}

// unit -> [byte*]
function getBadFrees() {
  return memcheck.errors.double_free;
}

// unit -> [{membyte: byte, trace: [str]}]
function getLeaks() {
  // take {byte* => {memval:bool, trace:[str]} and return [byte*]
  return memcheck.used.map(function(val, idx) {
    return [val.isalloc, idx, val.trace];
  }).filter(function(val, idx) {
    return val[0];
  }).map(function(val, idx) {
    return {membyte: val[1], trace: val[2]};
  });
}

let callstack = [];

function call_push(name, line, col) {
  callstack.push(name + ":" + line + ":" + col)
}
function call_pop() {
  callstack.pop()
}

function getCallstack() {
  return callstack;
}

// unit -> str
function report() {
  function fmtLeaks(leaks) {
    return leaks.map(function(val, idx) {
      return val.membyte + " allocated at:\n" + val.trace.join("\n");
    }).join("\n");
  }
  function fmtAccess(acc) {
    return acc.slice(0, 10).map(function(val, idx) {
      return val.membyte + " allocated at:\n" + val.trace.join("\n");
    }).join("\n")
  }
  
  let leaks = "Leaks found:\n" + fmtLeaks(getLeaks());
  let access = "Access of unallocaed memory:\n" + fmtAccess(getBadAccesses());
  let undef = "Undefined access at memory location: " + memcheck.errors.undef_access.length;
  let frees = "Frees: " + memcheck.errors.double_free.length;
  return [leaks, access, undef, frees].join("\n");
}

exports.setAddressable = setAddressable;
exports.isAddressable = isAddressable;
exports.setDefined = setDefined;
exports.isDefined = isDefined;
exports.setAlloc = setAlloc;
exports.isAlloc = isAlloc;

exports.addDoubleFreeError = addDoubleFreeError;
exports.addBadAccessError = addBadAccessError;
exports.addUndefinedError = addUndefinedError;

exports.getBadAccesses = getBadAccesses;
exports.getBadUndefined = getBadUndefined;
exports.getBadFrees = getBadFrees;
exports.getLeaks = getLeaks;

exports.report = report;
exports.reset = reset;

exports.memcheck_call_pop = call_pop;
exports.memcheck_call_push = call_push;
exports.getCallstack = getCallstack;
