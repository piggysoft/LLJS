extern undefined;
extern print;
extern console;
extern snarf;
extern process;
extern newGlobal;
extern setDebug;


let NODE_JS = 1;
let JS_SHELL = 2;
let BROWSER = 3;

let mode;
if (typeof process !== "undefined") {
  mode = NODE_JS;
} else if (typeof snarf !== "undefined") {
  mode = JS_SHELL;
} else {
  mode = BROWSER;
}

let ck, root, dbg;
if (mode === NODE_JS) {
  print = console.log;
} 

let memcheck = {}; 

function reset() {
  memcheck = {
    // {byte* => [bool, str]}
    used: [],
    // {byte* => bool}
    addressable: [],
    // {byte* => bool}
    valid: [],
    errors: {
      // [byte*]
      double_free: [],
      // [{membyte: byte*, trace: [str]]
      bad_access: [],
      // [{membyte: byte*, trace: [str]]
      undef_access: []
    }
  };
}

// (byte, uint, bool) -> unit
function setAddressable(byte *bt, uint size, value) {
  for (let i = 0; i < size; i++) {
    memcheck.addressable[bt + (byte *)(i)] = value;
  }
}

// (byte) -> bool
function isAddressable(byte *bt) {
  return memcheck.addressable[bt] === true;
}

// (byte, uint, bool) -> unit
function setValid(byte *bt, uint size, value) {
  // debugger;
  for (let i = 0; i < size; i++) {
    memcheck.valid[bt + (byte *) (i)] = value;
  }
}

// (byte) -> bool
function isValid(byte *bt) {
  return memcheck.valid[bt];
}

// (byte, bool) -> unit
function setAlloc(byte *bt, value) {
  memcheck.used[bt] = {isalloc:value, trace: callstack.slice(0)};
}

           

// (byte) -> bool
function isAlloc(byte *bt) {
  if(typeof memcheck.used[bt] !== 'undefined') {
    return memcheck.used[bt].isalloc;
  }
  return false;
}


// (str, str) -> unit
function addError(kind, msg) {
  if(memcheck.errors[kind] === undefined) {
    memcheck.errors[kind] = [];
  }
  memcheck.errors[kind].push(msg);
}

function addDoubleFreeError(byte *bt) {
  memcheck.errors.double_free.push({membyte: bt, trace: callstack.slice(0)});
} 

function addBadAccessError(byte *bt) {
  memcheck.errors.bad_access.push({membyte: bt, trace: callstack.slice(0) });
}

function addUndefinedError(byte *bt) {
  memcheck.errors.undef_access.push({membyte: bt, trace: callstack.slice(0)});
}

// unit -> [byte*]
function getBadAccesses() {
  return memcheck.errors.bad_access;
}

// unit -> [byte*]
function getBadUndefined() {
  return memcheck.errors.undef_access;
}

// unit -> [byte*]
function getBadFrees() {
  return memcheck.errors.double_free;
}

// unit -> [{membyte: byte, trace: [str]}]
function getLeaks() {
  // take {byte* => {memval:bool, trace:[str]} and return [byte*]
  return memcheck.used.map(function(val, idx) {
    return [val.isalloc, idx, val.trace];
  }).filter(function(val, idx) {
    return val[0];
  }).map(function(val, idx) {
    return {membyte: val[1], trace: val[2]};
  });
}

let callstack = [];

function call_push(name, line, col) {
  callstack.push(name + ":" + line + ":" + col)
}
function call_pop() {
  callstack.pop()
}

function getCallstack() {
  return callstack;
}

// unit -> str
function report() {
  let frees = "Double frees at memory location: " + memcheck.errors.double_free;
  let access = "Bad access at memory location: " + memcheck.errors.bad_access;
  let undef = "Undefined access at memory location: " + memcheck.errors.undef_access;
  let leaks = "Leaks at: " + getLeaks();
  return [frees, access, undef, leaks].join("\n");
}

exports.setAddressable = setAddressable;
exports.isAddressable = isAddressable;
exports.setValid = setValid;
exports.isValid = isValid;
exports.setAlloc = setAlloc;
exports.isAlloc = isAlloc;

exports.addDoubleFreeError = addDoubleFreeError;
exports.addBadAccessError = addBadAccessError;
exports.addUndefinedError = addUndefinedError;

exports.getBadAccesses = getBadAccesses;
exports.getBadUndefined = getBadUndefined;
exports.getBadFrees = getBadFrees;
exports.getLeaks = getLeaks;

exports.report = report;
exports.reset = reset;

exports.memcheck_call_pop = call_pop;
exports.memcheck_call_push = call_push;
exports.getCallstack = getCallstack;
