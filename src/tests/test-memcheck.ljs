extern undefined;
extern console;
extern process;
extern snarf;
extern print;
extern memory;
extern assertEq;

let NODE_JS = 1;
let JS_SHELL = 2;
let BROWSER = 3;

let mode;
if (typeof process !== "undefined") {
  mode = NODE_JS;
} else if (typeof snarf !== "undefined") {
  mode = JS_SHELL;
} else {
  mode = BROWSER;
}

let m, assert, assertTrue;
if (mode === NODE_JS) {
  m = require('memory');
  print = console.log;
  assert = require('assert').strictEqual;
  assertTrue = require('assert').ok;
} else {
  m = memory;
  //(load('memory.js'), memory);
  assert = assertEq;
  assertTrue = function(val) { assert(val, true); }
}


struct Node {
  u16 value;
  u16 other;
};

function isIn(byte *x, l) {
  return l.indexOf(x) >= 0;
}

let checker = m.checker;

function test_access() {
  function badGetU8() {
    let u8 *x = new u8;
    *x = 5;
    let u8 *badp = x + 1;
    let u8 good = *x;
    let u8 bad = *badp;

    assert(1, checker.getBadAccesses().length,
          "only had one bad access");
    assertTrue(isIn(badp, checker.getBadAccesses()),
              "tried to access a bad pointer");
  }
  
  function badGetI8() {
    let i8 *x = new i8;
    *x = 5;
    let i8 *badp = x + 1;
    let i8 good = *x;
    let i8 bad = *badp;

    assert(1, checker.getBadAccesses().length,
          "only had one bad access");
    assertTrue(isIn(badp, checker.getBadAccesses()),
              "tried to access a bad pointer");
  }
  
  function badGetU32() {
    let u32 *x = new int;
    *x = 5;
    let u32 *badp = x + 1;
    let u32 good = *x;
    let u32 bad = *badp;
    
    assert(1, checker.getBadAccesses().length,
          "only had one bad access");
    assertTrue(isIn(badp, checker.getBadAccesses()),
              "tried to access a bad pointer");
  }

  function badGetMixed() {
    // warm up some allocs
    for(let uint i = 0; i < 100; i++) {
      let u32 *x = new u32;
      // leaking all over the places but we don't care
    }
    let u32 *good = new u32;
    let u32 *badp = good + 1;
    
    // bad dereference
    let u32 bad = *badp;
    
    assert(1, checker.getBadAccesses().length,
          "only had one bad access");
    assertTrue(isIn(badp, checker.getBadAccesses()),
              "tried to access a bad pointer");
  }
  
  function badSet() {
    let int *badp;
    *badp = 4;
    assert(1, checker.getBadAccesses().length,
          "only had one bad access");
    assertTrue(isIn(badp, checker.getBadAccesses()),
              "tried to set a bad pointer");
  }

  print("running bad access tests (gets/sets of unallocated memory)...");
  
  m.reset();
  badGetU8();
  
  // m.reset();
  // badGetI8();
  
  // m.reset();
  // badGetU32();
  
  // m.reset();
  // badGetMixed();
  
  // m.reset();
  // badSet();
  
  print("done");
  m.reset();
}

function test_undefined() {
  function accessUndefined() {
    let int *x = new int;
    *x;
    
    assert(1, checker.getBadUndefined().length,
          "only had one bad access");
    assertTrue(isIn(x, checker.getBadUndefined()),
              "tried to get a bad memory location");
  }
  print("running undefined tests (gets of allocated but undefined memory)...");
  
  m.reset();
  accessUndefined();
  
  print("done");
  m.reset();
}

function test_frees() {
  function badFree() {
    let u32 *x;
    delete x;
    
    assert(1, checker.getBadFrees().length,
          "only had one bad access");
    assertTrue(isIn(x, checker.getBadFrees()),
              "tried to get a bad memory location");
  }
  
  function doubleFree() {
    let u32 *x = new u32;
    delete x;
    delete x;
    
    assert(1, checker.getBadFrees().length,
          "only had one bad access");
    assertTrue(isIn(x, checker.getBadFrees()),
              "tried to get a bad memory location");
  }
  
  print("running free tests (double frees, or general frees of unalloced memory)...");
  
  m.reset();
  badFree();
  
  m.reset();
  doubleFree();
  
  print("done");
  m.reset();
}


function test_leak() {
  function int leak() {
    let int *x = new int;
    
    assert(1, checker.getLeaks().length,
          "only had one leak ");
    assertTrue(isIn(x, checker.getLeaks()),
              "leaked an int");
  }
  
  print("running leak tests (forgot to call delete)...");
  
  m.reset();
  leak();
  
  print("done");
  m.reset();
}

test_access();
// test_undefined();
// test_frees();
// test_leak();

