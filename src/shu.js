// Generated by CoffeeScript 1.3.1
var o = (function() {
  var NALLOC, free, freep, malloc, morecore, _I16, _I32, _I8, _U16, $_U32, _U8, _ref;

  HEAPSIZE = 1024 * 1024 * 32;

  buf = new ArrayBuffer(HEAPSIZE);

  _I8 = new Int8Array(buf);

  _U8 = new Uint8Array(buf);

  _I16 = new Int16Array(buf);

  _U16 = new Uint16Array(buf);

  _I32 = new Int32Array(buf);

  $_U32 = $_U32 = new Uint32Array(buf);

  $_U32[0] = 8;

  $_U32[1] = HEAPSIZE;

  // type header = struct { [0] ptr :: *header, [4] size :: uint }

  // freep :: *header

  freep = 0;

  // malloc :: (uint) -> *any

  malloc = function(nbytes) { // :: (uint)
    var _U32 = $_U32;
    var nunits, p, prevp;
    // p, prevp :: *header
    // nunits :: uint
    nunits = ((nbytes + 8 - 1) / 8 + 1) >> 0;
    if (!(prevp = freep)) {
      prevp = freep = _U32[0] >> 2;
      _U32[0] += 8;
      _U32[freep] = freep;
      _U32[freep + 1] = 0;
    }
    p = _U32[prevp];
    while (true) {
      if (_U32[p + 1] >= nunits) {
        if (_U32[p + 1] === nunits) {
          _U32[prevp] = _U32[p];
        } else {
          _U32[p + 1] -= nunits;
          p += _U32[p + 1] * 2;
          _U32[p + 1] = nunits;
        }
        freep = prevp;
        return p + 1 * 2 << 2;
      }
      if (p === freep) {
        if (!(p = morecore(nunits))) {
          return 0;
        }
      }
      prevp = p;
      p = _U32[p];
    }
    return 0;
  };

  // NALLOC :: int

  NALLOC = 1024;

  // morecore :: (uint) -> *header

  morecore = function(nu) { // :: (uint)
    var _U32 = $_U32;
    var bytesNeeded, up;
    if (nu < NALLOC) {
      nu = NALLOC;
    }
    // print ("UNITS: " + nu);
    bytesNeeded = nu * 8;
    if (_U32[0] + bytesNeeded >= _U8.length) {
      return 0;
    }
    // up :: *header
    up = _U32[0] >> 2;
    _U32[up + 1] = nu;
    _U32[0] += bytesNeeded;
    free(up + 1 * 2 << 2);
    return freep;
  };

  // free :: (*any) -> any

  free = function(ap) { // :: (*any)
    var bp, p;
    var _U32 = $_U32;
    // bp, p :: *header
    bp = (ap >> 2) - 1 * 2;
    p = freep;
    while (!(bp > p && bp < _U32[p])) {
      if (p >= _U32[p] && (bp > p || bp < _U32[p])) {
        break;
      }
      p = _U32[p];
    }
    if (bp + _U32[bp + 1] * 2 === _U32[p]) {
      _U32[bp + 1] += _U32[_U32[p] + 1];
      _U32[bp] = _U32[_U32[p]];
    } else {
      _U32[bp] = _U32[p];
    }
    if (p + _U32[p + 1] * 2 === bp) {
      _U32[p + 1] += _U32[bp + 1];
      _U32[p] = _U32[bp];
    } else {
      _U32[p] = bp;
    }
    freep = p;
  };


var start = new Date();

function time (fn) {
  var start = new Date();
  fn();
  return new Date() - start;
}

var mTotal = 0, fTotal = 0;

var sum = 0;
for (var i = 0; i < 1000; i++) {
  var ptrs = new Uint32Array(10000);
  mTotal += time(function () {
    for (var j = 0; j < 10000; j++) {
      ptrs[j] = malloc(32);
      // print (ptrs[j]);
    }
  });

  fTotal += time(function () {
    for (var j = 0; j < 10000; j++) {
      // sum += (U4[ptrs[j] - 8 + 4 >> 2]);
      free(ptrs[j]);
    }
  });
}

print("Malloc: " + mTotal + ", Free: " + fTotal);

print("Done in " + (new Date() - start) + " checksum: " + sum);


}).call(this);