<html>
<head>
  <title>JS*</title>
  <link rel="stylesheet" type="text/css" href="css/docs.css" />
  <link rel="stylesheet" type="text/css" href="css/idle.css" />
</head>

<script src="vendor/lib/codemirror.js"></script>
<link rel="stylesheet" href="vendor/lib/codemirror.css">
<script src="vendor/mode/javascript/javascript.js"></script>

<script>
  print = function (x) {
    console.info(x);
  }
</script>
<script src="jc/util.js"></script>
<script>
  var options = new OptionSet("option(s)");
</script>
<script src="vendor/jquery-1.6.4.js"></script>
<script src="jc/esprima.js"></script>
<script src="jc/escodegen.js"></script>
<script src="jc/compiler.js"></script>
<script src="jc/memory.js"></script>
<body>
  <div class="container">
    <h1>*JS : Low-Level JavaScript</h1>
    <p>
      <b>*JS</b> is a typed dialect of JavaScript that offers a C-like type system with manual memory management.
      It compiles to JavaScript and lets you write memory-efficient and GC pause-free code less painfully, in short, *JS is the bastard child of JavaScript and C.
    </p>
    <p>
      *JS has 6 integral types: <tt>int -> i32</tt>, <tt>uint -> u32</tt>, <tt>i16</tt>, <tt>u16</tt>, <tt>i8</tt>, <tt>u8</tt>, which
      behave as they do in C, and two additional types: <tt>num</tt> (the JavaScript number type) and <tt>dyn</tt> (any type) which are used to interoperate with the JavaScript type system.
      In addition, *JS lets you define struct and pointer types.
    </p>

    <h4>Variables</h4>
    <p>
      Unlike JavaScript, *JS variable declarations are block scoped and can be annotated with type information.
    </p>

<pre class="example">
var x;               // Declare 'x' as dyn.

var int y;           // Declare 'y' as int.

y = (int) x;         // Assignment of 'x' to 'y' requires an explicit cast.

var int z = y + 1;   // Although 'y' is of type int, the binary expression
                     // y + 1 is of type num and requires an implicit cast.

var uint w = z;      // Unsigned types are suported but discouraged because
                     // they can be quite slow because they can overflow to
                     // doubles.
</pre>

<p>
  *JS lets you use pointers.
</p>

<pre class="example">
var int x = 42;      // Declare 'x' as int and assign '42' to it.

var int *y = &x;     // Declare 'y' as a pointer to int and assign it the address
                     // of x. Since JavaScript doesn't allow taking references to
                     // to variables, we allocate 'x' on an emulated stack.

var int **z = &y;    // Declare 'z' as a pointer to a pointer to int.

*y = 1;              // Assign to the variable pointed to by 'y'.

**z = ***(&z);       // You can get as fancy as you want.
</pre>

<h4>Functions</h4>

<p>
  *JS lets you type functions as well. A typed function is any function that has
  its return value or at least one of its arguments typed.
</p>

<pre class="example">

// Declare 'foo' as dyn, normal JavaScript function.
function foo () { }

// Declare 'bar' as () -> void, typed *JS function.
function void bar () { }

// Declare 'baz' as (int, int*) -> void, typed *JS function with typed arguments.
function void baz (int x, int *y) { }

// Declare 'car' as (int, dyn, int x) -> dyn, typed *JS function with mixed typed
// and untyped arguments.
function car (int x, y, int z) { }

// Call 'car', arguments are coerced to the callee's parameter types.
car("123", 2, 123.456);

// The type system is not smart enough to track types that leak into the dynamic
// type system. Safety is your responsability.
var val = car;

// Calling 'var' is not safe.
val("123", 2, 123.456);

</pre>

<p>
  For example, you can implement a <tt>swap</tt> function in *JS as follows:
</p>

<pre class="example">

function void swap(int *a, int *b) {
  var int t = *a;
  *a = *b;
  *b = t;
}

var int x, y;

swap(&x, &y);

</pre>


<h4>Objects and Memory</h4>

<p>
  *JS has two object models: C style <tt>malloc</tt> and <tt>free</tt>, and the JavaScript object model.
  Why would you ever want to mange your memory explicitly when the JavaScript garbage collector already does the work for you.
  <!--  (*JS offers limited support for interoperability between the two, for now at least.) -->
  Well imagine you wanted to write a linked list in JavaScript.
  You would probably chain a sequence of objects together, like so:
</p>
<pre>
 var head = {value: 0, next: null}, tail = head;

 function add(value) {
   var next = {value: value, next: null};
   tail.next = next;
   tail = next;
 }
</pre>
    <p>
      This is inefficient for several reasons. Objects in JavaScript are not cheap, they need to carry around lots of extra information and can be
      many times larger than their C style counterparts, moreover property access is slow. In *JS you can write a much more efficient linked list
      using pointers and structs. The code below uses <tt>malloc</tt> to allocate memory, which is modeled using typed arrays.
      (<tt>I32</tt> and <tt>U32</tt> are typed signed/unsigned views over one large array buffer.)
      With great power comes great responsibility, so what is malloc'ed must be freed, even in JavaScript.
    </p>

<pre class="example">
struct Node {
  var Node *next;
  var int value;
}

var Node *head = new Node, *tail = head;

function void add (int value) {
  var Node * next = new Node;
  next->value = value;
  tail->next = next;
  tail = next;
}
</pre>
    <p>
      <tt>malloc</tt> and <tt>free</tt> are themselves implemented in *JS, see proof below:
    </p>
<pre class="example">
/* K&R Malloc */

struct Header {
  var Header * next;
  var uint size;
}

var Header base;
var Header * freep = NULL;

function void * sbrk(int nBytes) {
  var int nWords = nBytes / sizeof (u32);
  if ($HP + nWords > $HP_END) {
    extern.assert("Ran out of memory.");
    return NULL;
  }
  var void * address = $HP;
  $HP += nWords;
  return address;
}

var uint nUnitsMin = 1024;

function Header * morecore(uint nUnits) {
  if (nUnits < nUnitsMin) {
    nUnits = nUnitsMin;
  }
  var void * buffer = sbrk(nUnits * sizeof (Header));

  if (buffer === 0) {
    return NULL;
  }
  var Header * header = (Header *)buffer;
  header->size = nUnits;
  free(header + 1);
  return freep;
}

function void * malloc(int nBytes) {
  var Header *p, *prevp;
  var uint nUnits = ((nBytes + sizeof(Header) - 1) / sizeof(Header)) + 1;
  if ((prevp = freep) === NULL) {
    base.next = freep = prevp = &base;
    base.size = 0;
  }
  for (p = prevp->next; true; prevp = p, p = p->next) {
    if (p->size >= nUnits) {
      if (p->size === nUnits) {
        prevp->next = p->next;
      } else {
        p->size -= nUnits;
        p += p->size;
        p->size = nUnits;
      }
      freep = prevp;
      return p + 1;
    }
    if (p === freep) {
      if ((p = morecore(nUnits)) == NULL) {
        return NULL;
      }
    }
  }
  return NULL;
}

function void free(void *ap) {
  var Header *bp = (Header *)ap - 1, *p;
  for (p = freep; !(bp > p && bp < p->next); p = p->next) {
    if (p >= p->next && (bp > p || bp < p->next)) {
      break;
    }
  }
  if (bp + bp->size === p->next) {
    bp->size += p->next->size;
    bp->next = p->next->next;
  } else {
    bp->next = p->next;
  }
  if (p + p->size == bp) {
    p->size += bp->size;
    p->next = bp->next;
  } else {
    p->next = bp;
  }
  freep = p;
}
</pre>
</div>

<script>
/*
var myCodeMirror = CodeMirror(document.body, {
  value: "function myScript(){return 100;}\n",
  mode:  "javascript"
});
*/
</script>

<script>
var id = 0;
$('.example').replaceWith(function() {
  var src = this.innerHTML;
  var lineCount = src.split("\n").length;
  return '<table class="example"><tr><td><textarea id="ex:' + id + ':source" class="jcCode" rows="' + lineCount + '" spellcheck="false">' + src + '</textarea></td><td valign="top"><pre id="ex:' + id++ + ':result" class="jcResult"></pre></td></tr></table>'
  // <div class="minibutton ok run" title="Ctrl-Enter">Run</div>
});

function compileExample(id) {
  var number = id.split(":")[1];
  var result = document.getElementById("ex:" + number + ":result");
  try {
    var node = esprima.parse(this.getValue(), {loc: true});
    compile(node);
    result.innerHTML = escodegen.generate(node, {base: "", indent: "  "});
  } catch (x) {
    result.innerHTML = x.message;
  }
}

var extern = {};

function executeExample(id) {
  var number = id.split(":")[1];
  var result = document.getElementById("ex:" + number + ":result");
  try {
    resetMemory();
    result.innerHTML = "";
    extern.trace = function (x) {
      result.innerHTML += x;
    };
    new Function (compile(this.value))();
  } catch (x) {
    result.innerHTML = x.message;
  }
}

$('.jcCode').each(function() {
  var id = this.id;
  var cm = CodeMirror.fromTextArea(this, {
    tabSize: 2,
    onChange: function () {
      compileExample.call(cm, id);
    }
  });
  compileExample.call(cm, id);
});

</script>
</body>
</html>
